import { jest } from '@jest/globals';
import puppeteer from 'puppeteer';
import { spawn } from 'child_process';

describe('Game Integration Tests', () => {
  let browser;
  let page;
  let server;
  const PORT = 8081;
  const BASE_URL = `http://localhost:${PORT}`;

  beforeAll(async () => {
    // Start HTTP server
    server = spawn('python3', ['-m', 'http.server', PORT.toString()], {
      cwd: process.cwd()
    });
    
    // Wait for server to start
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Launch browser
    browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
  }, 30000);

  afterAll(async () => {
    if (browser) await browser.close();
    if (server) {
      server.kill();
      // Wait for server to fully shut down
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  });

  beforeEach(async () => {
    page = await browser.newPage();
    await page.setViewport({ width: 1280, height: 720 });
    
    // Set up console log capture
    page.on('console', msg => {
      if (msg.type() === 'error') {
        console.error('Browser console error:', msg.text());
      }
    });
    
    // Set up error capture
    page.on('error', err => {
      console.error('Page error:', err);
    });
    
    page.on('pageerror', err => {
      console.error('Page error:', err);
    });
  });

  afterEach(async () => {
    if (page) await page.close();
  });

  describe('Main Game (index.html)', () => {
    test('should load without errors', async () => {
      const response = await page.goto(`${BASE_URL}/index.html`, { 
        waitUntil: 'networkidle2',
        timeout: 10000 
      });
      expect(response.status()).toBe(200);
    });

    test('should initialize game components', async () => {
      await page.goto(`${BASE_URL}/index.html`, { waitUntil: 'networkidle2' });
      
      // Wait for game initialization
      await page.waitForFunction(() => {
        return window.game !== undefined;
      }, { timeout: 5000 });
      
      // Check game components are initialized
      const gameState = await page.evaluate(() => {
        const game = window.game;
        return {
          hasScene: game.scene !== undefined,
          hasVehicle: game.vehicle !== undefined,
          hasEnvironment: game.environment !== undefined,
          hasInput: game.input !== undefined,
          hasTraffic: game.traffic !== undefined,
          hasCones: game.cones !== undefined
        };
      });
      
      expect(gameState.hasScene).toBe(true);
      expect(gameState.hasVehicle).toBe(true);
      expect(gameState.hasEnvironment).toBe(true);
      expect(gameState.hasInput).toBe(true);
      expect(gameState.hasTraffic).toBe(true);
      expect(gameState.hasCones).toBe(true);
    });

    test('should display UI elements', async () => {
      await page.goto(`${BASE_URL}/index.html`, { waitUntil: 'networkidle2' });
      
      // Check for UI elements
      const uiElements = await page.evaluate(() => {
        return {
          hasScore: document.getElementById('score') !== null,
          hasSpeed: document.getElementById('speed') !== null,
          hasDistance: document.getElementById('distance') !== null,
          hasControls: document.querySelector('.controls') !== null
        };
      });
      
      expect(uiElements.hasScore).toBe(true);
      expect(uiElements.hasSpeed).toBe(true);
      expect(uiElements.hasDistance).toBe(true);
      expect(uiElements.hasControls).toBe(true);
    });

    test('should respond to keyboard input', async () => {
      await page.goto(`${BASE_URL}/index.html`, { waitUntil: 'networkidle2' });
      
      // Wait for game to initialize
      await page.waitForFunction(() => window.game !== undefined, { timeout: 5000 });
      
      // Test acceleration
      await page.keyboard.down('ArrowUp');
      await page.waitForTimeout(100);
      
      const accelerating = await page.evaluate(() => {
        return window.game.input.isAccelerating();
      });
      expect(accelerating).toBe(true);
      
      await page.keyboard.up('ArrowUp');
      
      // Test steering
      await page.keyboard.down('ArrowLeft');
      await page.waitForTimeout(100);
      
      const steeringLeft = await page.evaluate(() => {
        return window.game.input.isSteeringLeft();
      });
      expect(steeringLeft).toBe(true);
      
      await page.keyboard.up('ArrowLeft');
    });

    test('should update vehicle speed', async () => {
      await page.goto(`${BASE_URL}/index.html`, { waitUntil: 'networkidle2' });
      
      // Wait for game to initialize
      await page.waitForFunction(() => window.game !== undefined, { timeout: 5000 });
      
      // Get initial speed
      const initialSpeed = await page.evaluate(() => window.game.vehicle.speed);
      
      // Accelerate
      await page.keyboard.down('ArrowUp');
      await page.waitForTimeout(500);
      await page.keyboard.up('ArrowUp');
      
      // Get new speed
      const newSpeed = await page.evaluate(() => window.game.vehicle.speed);
      
      expect(newSpeed).toBeGreaterThan(initialSpeed);
    });
  });

  describe('Simple Test Page (simple.html)', () => {
    test('should load without errors', async () => {
      const response = await page.goto(`${BASE_URL}/simple.html`, { 
        waitUntil: 'networkidle2',
        timeout: 10000 
      });
      expect(response.status()).toBe(200);
    });
  });

  describe('Debug Page (debug.html)', () => {
    test('should load without errors', async () => {
      const response = await page.goto(`${BASE_URL}/debug.html`, { 
        waitUntil: 'networkidle2',
        timeout: 10000 
      });
      expect(response.status()).toBe(200);
    });
  });

  describe('Mobile Test Page (test-mobile.html)', () => {
    test('should load on mobile viewport', async () => {
      await page.setViewport({ width: 375, height: 667, isMobile: true });
      const response = await page.goto(`${BASE_URL}/test-mobile.html`, { 
        waitUntil: 'networkidle2',
        timeout: 10000 
      });
      expect(response.status()).toBe(200);
    });

    test('should handle touch input', async () => {
      await page.setViewport({ width: 375, height: 667, isMobile: true });
      await page.goto(`${BASE_URL}/test-mobile.html`, { waitUntil: 'networkidle2' });
      
      // Wait for game to initialize
      await page.waitForFunction(() => window.game !== undefined, { timeout: 5000 });
      
      // Simulate touch
      await page.touchscreen.tap(200, 400);
      
      // Check if touch was registered (this depends on your implementation)
      const touchActive = await page.evaluate(() => {
        return window.game && window.game.input && window.game.input.isTouchActive ? 
          window.game.input.isTouchActive() : false;
      });
      
      // Note: Touch might not stay active after tap, but this tests the touch handling
      expect(touchActive).toBeDefined();
    });
  });

  describe('Performance Tests', () => {
    test('should maintain acceptable frame rate', async () => {
      await page.goto(`${BASE_URL}/index.html`, { waitUntil: 'networkidle2' });
      
      // Wait for game to initialize
      await page.waitForFunction(() => window.game !== undefined, { timeout: 5000 });
      
      // Let the game run for a bit
      await page.waitForTimeout(3000);
      
      // Check FPS
      const fps = await page.evaluate(() => {
        return window.game.fps;
      });
      
      // Expect at least 30 FPS
      expect(fps).toBeGreaterThan(30);
    });

    test('should not have memory leaks in short session', async () => {
      await page.goto(`${BASE_URL}/index.html`, { waitUntil: 'networkidle2' });
      
      // Wait for game to initialize
      await page.waitForFunction(() => window.game !== undefined, { timeout: 5000 });
      
      // Get initial memory usage
      const initialMemory = await page.evaluate(() => {
        if (performance.memory) {
          return performance.memory.usedJSHeapSize;
        }
        return 0;
      });
      
      // Play for a bit
      await page.keyboard.down('ArrowUp');
      await page.waitForTimeout(5000);
      await page.keyboard.up('ArrowUp');
      
      // Force garbage collection if available
      await page.evaluate(() => {
        if (global.gc) global.gc();
      });
      
      await page.waitForTimeout(1000);
      
      // Get final memory usage
      const finalMemory = await page.evaluate(() => {
        if (performance.memory) {
          return performance.memory.usedJSHeapSize;
        }
        return 0;
      });
      
      // Memory should not increase dramatically (allow 50MB increase)
      if (initialMemory > 0 && finalMemory > 0) {
        const memoryIncrease = (finalMemory - initialMemory) / 1024 / 1024; // Convert to MB
        expect(memoryIncrease).toBeLessThan(50);
      }
    });
  });

  describe('Game Mechanics', () => {
    test('should track distance traveled', async () => {
      await page.goto(`${BASE_URL}/index.html`, { waitUntil: 'networkidle2' });
      
      // Wait for game to initialize
      await page.waitForFunction(() => window.game !== undefined, { timeout: 5000 });
      
      // Get initial distance
      const initialDistance = await page.evaluate(() => window.game.vehicle.distanceTraveled);
      
      // Move forward
      await page.keyboard.down('ArrowUp');
      await page.waitForTimeout(2000);
      await page.keyboard.up('ArrowUp');
      
      // Get new distance
      const newDistance = await page.evaluate(() => window.game.vehicle.distanceTraveled);
      
      expect(newDistance).toBeGreaterThan(initialDistance);
    });

    test('should handle vehicle reset', async () => {
      await page.goto(`${BASE_URL}/index.html`, { waitUntil: 'networkidle2' });
      
      // Wait for game to initialize
      await page.waitForFunction(() => window.game !== undefined, { timeout: 5000 });
      
      // Move the vehicle
      await page.keyboard.down('ArrowUp');
      await page.waitForTimeout(1000);
      await page.keyboard.up('ArrowUp');
      
      // Reset
      await page.keyboard.press('r');
      await page.waitForTimeout(500);
      
      // Check vehicle state
      const vehicleState = await page.evaluate(() => {
        const vehicle = window.game.vehicle;
        return {
          speed: vehicle.speed,
          crashed: vehicle.crashed,
          position: {
            x: vehicle.position.x,
            y: vehicle.position.y,
            z: vehicle.position.z
          }
        };
      });
      
      expect(vehicleState.speed).toBe(20); // Default speed
      expect(vehicleState.crashed).toBe(false);
    });
  });
});